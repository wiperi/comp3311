<title>COMP3311 Week 2 Thursday Lecture
<footer>COMP3311 25T1 <diamond> Week 2 Thursday Lecture <diamond>

<slide>
<heading>Week 02 Thursday</heading>
<subheading>In today's lecture ...</subheading>
<itemize>
<item> Assignment 1 DB preview
<item> More ER <rightarrow> SQL, and SQL DDL
<item> Building/modifying/restoring a database
<item> Assignment 1 released on Saturday, due end week 5
</itemize>
<subheading>Things to do ...</subheading>
<itemize>
<item> Quiz before Friday midnight
<item> Set up your PostgreSQL server <br>
        <smaller>(520 students have logged in to vxdb02 and have /localstorage)</smaller>
</itemize>
</slide>

<slide>
<heading>Assignment 1 Database Schema
Database about cheeses, cheese styles, and cheese makers
<p><br>
<diagram>Pics/assignments/cheese1
</slide>

<slide>
<continued>
Details of entities, with example data <small>(does not include all entities)</small>:
<program80>
Cheeses(<b>id</b>, name, style, made_by, aged_for, fat, notes)

(123, 'Stokes Point', 456, 321, '4 months', 15, 'smoked')

Makers(<b>id</b>, name, founded, located_in)

(321, 'King Island Dairy Co', 1902, 621)

Styles(<b>id</b>, name, origin, hardness, milk, min_aging, max_aging)

(456, 'Cheddar', 654, 'semi-hard', 'cow', '2 months', '24 months')

Places(<b>id</b>, country, region, town)

(654, 'UK', 'Gloucester', 'Cheddar')
(621, 'Australia', 'King Island', 'Loorana')
</program>
</slide>

<slide>
<exercise>ER-to-SQL for Cheese Database
Convert the cheese ER data model to an SQL schema
<itemize>
<item> assume that each entity has (at least) attributes <@>id</@> and <@>name</@>
</itemize>
<diagram>Pics/assignments/cheese1
</slide>

<slide>
<exercise> ER-to-SQL (2)
Convert this ER design to SQL:
<p>
<diagram>Pics/er-rel/emp-dept-proj.png
</slide>

<slide>
<exercise> ER-to-SQL (3)
Convert the Publishing ER model to SQL
<p>
<diagram>Pics/er-rel/publishing.png
<p>
<small>
<itemize>
<item> A TFN is stored as a 9-digit number
<item> An ABN is stored as an 11-digit number 
<item> An ISBN (13-digit version) looks like 978-3-16-148410-0
</itemize>
</small>
</slide>

<slide>
<heading>Modifying PostgreSQL databases
PostgreSQL commands for manipulating databases
<program>
<blue>dropdb</blue> DatabaseName
<blue>createdb</blue> DatabaseName
<blue>pg_dump</blue> DatabaseName <blue>&gt;</blue> NewDumpFile
<blue>psql</blue> DatabaseName [ <blue>-f</blue> FileOfSQLStatements ]
</program>
SQL commands for changing data in a database from within <@>psql</@>
<program>
<green>insert into</green> Table <green>values (</green> Val1, Val2, ... <green>)</green>
<green>delete from</green> Table <green>where</green> Condition
<green>update</green> Table <green>set</green> Field <green>=</green> Value <green>where</green> Condition
<green>create table</green> Table <green>(</green> Attributes/Constraints <green>)</green>
<green>drop table</green> Table
<green>copy</green> Table from ...   <comment>-- PostgreSQL specific</comment>
</program>
</slide>

<slide>
<heading>PostgreSQL Databases
Create a database in PostgreSQL via
<program>
$ <green>createdb</green>  <i>DatabaseName</i>
</program>
Creates an empty database (no schema, no data)
<p>
Remove a database in PostgreSQL via
<program>
$ <green>dropdb</green>  <i>DatabaseName</i>
</program>
Removes schema and all data permanently
<p>
Remove an entire PostgreSQL server (on <@>vxdb02</@>)
<program>
$ rm -fr /localstorage/$USER/pgsql
</program>
Removes all server files, all databases, all data !
</slide>

<slide>
<heading><@>psql</@>
The <@@>psql</@@> command is a shell that allows you to
<itemize>
<item> conect to databases <~><smaller>(one at a time)</smaller>
<item> ask SQL queries on a database
<item> find information (meta data) about a database
<item> add/delete/update tuples in tables
</itemize>
Usage:
<program90>
$ <green>psql</green>  mydb
...
mydb=# \d
...
mydb=$ select * from SomeTable;
...
mydb=# \q
</program>
</slide>

<slide>
<continued>
<br>
A useful way to use <~> <@>psql</@>:
<program>
$ <green>psql</green> -l
</program>
Gives a list of all databases under your PostgreSQL server.
<p>
The "databases" <~> <@>postgres</@>, <~><@>template1</@>, <~> <@>template2</@>
<itemize>
<item> are special databases used internally by PostgreSQL
<item> do not <~><@>dropdb</@><~> them
</itemize>
</slide>

<slide>
<continued>
SQL statements can span several lines, terminated by typing <@@>;</@@>
<p>
The <@@>psql</@@> command has several prompts <smaller(to indicate it's waiting for input)</smaller>
<itemize>
<item> <@@>db=#</@@> ... waiting to start an SQL statement <small>(or psql meta-command)</small>
<item> <@@>db-#</@@> ... waiting for rest of SQL statement
<item> <@@>db(#</@@> ... waiting for rest of expression <~><@>(...)</@>
<item> <@@>db'#</@@> ... waiting to finish a string <smaller>(expecting closing <@@>'</@@>)</smaller>
</itemize>
Note that <@@>db</@@> will be (replaced by) the name of the current database
<p>
Note that <@@>#</@@> means you are super-user; normal users get <@@>>></@@>
<p>
<@>psql</@> meta-commands are single-line commands
</slide>

<slide>
<continued>
<br>
<@@>psql</@@> has a range of <em>meta-commands</em>, beginning with <@@>\</@@>
<itemize>
<item> <@@>help</@@> ... a quick list of useful meta-commands
<item> <@@>\?</@@> ... a list of all meta-commands <smaller>(very many of them)</smaller>
<item> <@@>\d</@@> ... list of all tables and views in current schema
<item> <@@>\dt</@@> ... list of all tables in current schema
<item> <@@>\d</@@> <i>Table</i> ... list of all attributes in <i>Table</i>
<item> <@@>\df</@@> ... list of all user-defined functions in current schema
<item> <@@>\q</@@> ... exit <@@>psql</@@>
</itemize>
</slide>

<slide>
<exercise>Creating a database
On <@>vxdb02</@>, do the following:
<itemize>
<item> create a database called <@>xyz</@>
<item> examine its (empty) schema
<item> within <@>xyz</@> create a table
<program90>
create table R (
   x integer primary key,
   y float not null,
   z text
);
</program>
<item> examine the schema again
<item> examine the attributes of table <@>R</@>
<item> how many tuples are in table <@>R</@>?
<item> remove the database <@>xyz</@>
</itemize>
</slide>

<slide>
<heading>Populating a Database
Basic way of adding tuples to a database:
<program>
db=# <@@>insert into</@@> <i>Table</i> <@@>values (</@@><i>val<sub>1</sub>,val<sub>2</sub>,...</i><@@>);</@@>
</program>
Adds a tuple to table <@><i>Table</i></@> assuming
<itemize>
<item> values satisfy all constraints on tuples/table
</itemize>
Ways it can fail ...
<itemize>
<item> value for primary key field is already in the table
<item> tuple has <~><@>null</@></@> values for fields defined as <~><@>not null</@>
<item> value for some field violates constraints on that field
<item> etc. etc. etc.
</itemize>
</slide>

<slide>
<exercise>Inserting Tuples
Which <~><@>insert</@><~> statements are successful? <br>
If successful, what tuple value is inserted?
<program90>
create type Mood as enum ('sad','happy');

create table People (
	name text not null,
	feels Mood
);

insert into People values ('John','happy');
insert into People values ('Andrew','angry');
insert into People values ('Tina',null);
insert into People(name) values ('Anne');
insert into People(feels) values ('happy');
</program>
</slide>

<slide>
<exercise>More Inserting Tuples
Which <~><@>insert</@><~> statements are successful? <br>
If successful, what tuple value is inserted?
<program90>
create domain PosInt as integer check (value > 0);

create table Points (
	x PosInt default 1,
	y posint
);

insert into Points values (3,4);
insert into Points values (3,null);
insert into Points values (-3,4);
insert into Points(y) values (5);
insert into Points values (default,5);
</program>
</slide>

<slide>
<heading>Updating Tuples
Existing tuples can be modified "in place":
<program>
<@@>update</@@> <i>Table</i>
<@@>set</@@>    <i>Field</i> = <i>Expression</i>
<@@>where</@@>  <i>Condition</i>
</program>
Note that <@><i>Expression</i></@>
<itemize>
<item> could be a constant value
<item> could be an expression involving the <@><i>Field</i></@>
</itemize>
<@><i>Condition</i></@> can match zero or more tuples
<itemize>
<item> all matching tuples will have the update applied to them
</itemize>
If no <@@>where</@@> clause, all tuples in <@><i>Table</i></@> are updated
</program>
</slide>

<slide>
<continued>
<br>
Examples:
<program>
<comment>-- change a student's address</comment>

update Students
set    address = '356 Rainbow St, Coogee'
where  id = 5544332;

<comment>-- make all white parts red</comment>

update Parts set colour='red' where colour='white';

<comment>-- give all employees a 20% raise</comment>

update Employees set salary = salary * 1.2;
</program>
</slide>

<slide>
<heading>Deleting Tuples
<br>
Tuples can be permanently removed:
<program>
<@@>delete</@@> <@@>from</@@> <i>Table</i> <@@>where</@@> <i>Condition</i>
</program>
Removes all tuples from <@><i>Table</i></@> satisfying <@><i>Condition</i></@>
<p>
If <@><i>Condition</i></@> is <@>True</@> (or omitted), all tuples are deleted
<p>
Be careful to precisely specify <@><i>Condition</i></@>
<p>
If any tuple is referenced from elsewhere, deletion will fail.
</slide>

<slide>
<continued>
<br>
Examples:
<program>
<comment>-- remove all red products</comment>

delete from Products where colour = 'red';

<comment>-- cancel all enrolments in COMP4321 25T1</comment>

delete from Enrolments
where  course='COMP4321' and term='25T1'

<comment>-- sack everybody (the Elon Musk solution)</comment>

delete from Employees;
</program>
</slide>

<slide>
<exercise>Yet More Modifying Tuples
Consider the following SQL schema:
<program90>
create table Student (
    id      serial primary key,
    name    text not null,
    degree  numeric(4)
);
create table Course (
    id      integer primary key,
    code    char(8) check (code ~ '[A-Z]{4}[0-9]{4}'),
    term    char(4) check (term ~ '[0-9]{2}T[0123]')
);
create table Enrolment (
    stuID   integer references Student(id),
    crsID   integer references Course(id),
    mark    integer check (mark between 0 and 100),
    grade   char(2)
            check (grade in ('HD','DN','CR','PS','FL'))
);
</program>
</slide>

<slide>
<continued>
State what the effect of each of these statements would be:
<program80>
<comment>-- Student(id,name,degree),  Course(id,title,term)</comment>
<comment>-- Enrolment(stuID,crsID,grade,mark)</comment>

<comment>-- assume 'student_id_seq' has value 5654320</comment>
insert into Student(name,degree) values ('John',3778);
insert into Student(name,degree) values ('Jack',3778) returning id;
insert into Student(id,name,degree) values (default,'Bill',3778);

insert into Course values (987, 'COMP3311', '25T1');

insert into Enrolment(stuID,crsID) values(5654321, 987);

<comment>-- update mark for one student</comment>
update Enrolment set mark=75, grade='DN' where stuID = 5654321;
<comment>-- adjust marks for all students in the course</comment>
update Enrolment set mark=mark*1.1 where crsID = 987;

<comment>-- a student drops the course</comment>
delete from Enrolment where stuID = 5554321 and crsID = 987;
</program>
</slide>

<slide>
<heading>Another Example Database: Beers/Bars/Drinkers
Consider the following ER model:
<p>
<div align="center">
<diagram>Pics/exercises/beer1
</div>
Define an SQL schema for this database
</slide>

<slide>
<exercise>Delete/Update Examples
<br>
Give SQL statements to carry out the following actions:
<itemize>
<item> Insert a new beer "Jumping the Shark" from MoonDog
<item> Sell "Jumping the Shark" for $5.00 at Marble Bar
<item> Increase the prices for all beers by 10%
<item> Remove all drinkers who live in Randwick
<item> Remove all beers selling for more than 5.00
<item> Close down the Marble Bar <smaller>(it really did close)</smaller>
</itemize>
</slide>

<slide>
<heading>Bulk Insertion
Entering tuples interactively one-by-one is not feasible
<p>
Alternative: put <~><@>insert</@><~> statements in a file and run
<program>
$ <@@>psql</@@> <i>DatabaseName</i> <@@>-f</@@> <i>FileName</i>
</program>
Attempts to execute each <@>insert</@> statement:
<itemize>
<item> if tuple valid, inserted into database
<item> if tuple not valid, prints error message, then continues
</itemize>
<br>
Note that <@><i>FileName</i></@> can contain any SQL statements
<p>
Might consist only of <~><@>create table</@><~> statements to build a schema
</slide>

<slide>
<continued>
A common way of building a database
<program>
$ createdb mydb
$ psql mydb -f schema.sql
$ psql mydb -f data.sql
</program>
where
<itemize>
<item> <@>schema.sql</@> contains table and type definitions
<item> <@>data.sql</@> contains statements to insert tuples
</itemize>
</slide>

<slide>
<continued>
<br>
How I "debug" a database schema
<program>
$ dropdb mydb
$ createdb mydb
$ psql mydb -f schema.sql > .errs 2>&amp;1
$ vi .errs
<comment>  # fix any errors that appear in .errs</comment>
$ psql mydb -f data.sql > .errs 2>&amp;1
$ vi .errs
<comment>  # fix any errors that appear in .errs</comment>
</program>
Repeat until <@>.errs</@> contains no lines with <@>ERROR</@>
</slide>

<slide>
<continued>
Alternative way of inserting tuples
<program>
<green>copy</green> <i>TableName</i> <@@>(</@@> <i>attribute names</i> <@@>) from stdin;</@@>
<comment>... lines containing tab-separated values ...</comment>
<comment>... one value for each of the named attributes ...</comment>
<@@>\.</@@>
</program>
Difference between <@@>copy</@@> and multiple <@@>insert</@@>s
<itemize>
<item> with <@@>insert</@@> ...
<itemize>
<item> all tuples with valid values are inserted
<item> tuples with invalid values are not inserted
</itemize>
<item> with <@@>copy</@@> ...
<itemize>
<item> if any tuple contains invlid values, nothing is inserted
</itemize>
</itemize>
</slide>

<slide>
<heading>Dump/Restore
Once a database is built, can make a complete copy in a text file
<itemize>
<item> the whole schema <small>(including types, constraints, etc)</small>, and all data
</itemize>
by running the command
<program>
$ <@@>pg_dump -O -x</@@> <i>DatabaseName</i> > <i>DumpFileName</i>
</program>
and can make a new copy via
<program>
$ <@@>createdb</@@> newdb
$ <@@>psql</@@> newdb <@@>-f</@@> <i>DumpFileName</i>
</program>
We generally supply databases using pre-built dump files
</slide>
